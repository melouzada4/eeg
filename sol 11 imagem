 ============================================================
# EEG ANALYSIS — FOOOF + PLOTS PARA PUBLICAÇÃO
# Pipeline: Welch por segmento -> média PSD -> FOOOF 1x -> métricas
# Plot: 3 painéis (espectro completo | periódico + gaussianas | E/I barplot)
# Estilo: Frontiers / PLOS / Brain Sciences — DPI 300
# Referência: Donoghue et al. (2020) Nature Neuroscience
# ============================================================

import os
import json
import platform
from datetime import datetime
from pathlib import Path
import warnings
import gc

import numpy as np
import pandas as pd
import mne
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.gridspec import GridSpec
from matplotlib.lines import Line2D
from scipy.signal import welch
from fooof import FOOOF

# =========================
# SILENCIAR AVISOS
# =========================
mne.set_log_level("WARNING")
warnings.filterwarnings("ignore", category=DeprecationWarning, module=r"^fooof(\.|$)")
warnings.filterwarnings("ignore", category=RuntimeWarning)
warnings.filterwarnings("ignore", category=DeprecationWarning, message=r".*fooof.*deprecated.*")
warnings.filterwarnings("ignore", category=UserWarning)

# =========================
# CONFIGURAÇÕES
# =========================
DURACAO_INTERVALO  = 6
NUM_INTERVALOS_OA  = 10
NUM_INTERVALOS_OF  = 10

FMIN_GLOBAL = 1.0
FMAX_GLOBAL = 40.0

BANDAS = {
    "delta": (1.0,  4.0),
    "theta": (4.0,  8.0),
    "alpha": (8.0, 13.0),
    "beta":  (13.0, 30.0),
}

WELCH_WIN_SEC      = 2.0
WELCH_OVERLAP_FRAC = 0.5
NFFT_MIN           = 2048

FOOOF_CONFIG = {
    "peak_width_limits": [1, 12],
    "max_n_peaks":        3,
    "min_peak_height":    0.01,
    "peak_threshold":     2.0,
    "aperiodic_mode":    "fixed",
    "verbose":            False,
}

FOOOF_R2_MIN  = 0.70
FOOOF_ERR_MAX = 0.30

# =========================
# PALETA — colorblind-safe
# =========================
COR_OA    = "#2166AC"   # azul escuro
COR_OF    = "#D6604D"   # vermelho
COR_AP_OA = "#92C5DE"   # azul claro (aperiódico OA)
COR_AP_OF = "#F4A582"   # salmão    (aperiódico OF)

BANDAS_PLOT = {
    "δ": (1.0,  4.0,  "#D9EAF7", 0.30),
    "θ": (4.0,  8.0,  "#FDEBD0", 0.30),
    "α": (8.0,  13.0, "#D5F5E3", 0.38),
    "β": (13.0, 30.0, "#F9EBEA", 0.25),
}

# =========================
# CAMINHOS
# =========================
PASTA_SET      = r'C:/Users/meloliveira/Documents/eeg'
PLANILHA_PATH  = r'C:/Users/meloliveira/Documents/intervalos_pacientes.xlsx'
SUBPASTA_SAIDA = "sol11"
PASTA_SAIDA    = os.path.join(PASTA_SET, SUBPASTA_SAIDA)
os.makedirs(PASTA_SAIDA, exist_ok=True)


# =========================
# PLANILHA
# =========================
def carregar_intervalos_planilha(caminho_planilha):
    df     = pd.read_excel(caminho_planilha)
    col_id = df.columns[0]
    intervalos = {}

    for _, row in df.iterrows():
        id_str = str(row[col_id]).strip()
        if not id_str or id_str.lower() == "nan":
            continue

        oa = [int(row.iloc[i]) for i in range(1, 11)
              if i < len(row) and not pd.isna(row.iloc[i])]
        of = [int(row.iloc[i]) for i in range(11, 21)
              if i < len(row) and not pd.isna(row.iloc[i])]

        if len(oa) >= 10 and len(of) >= 10:
            intervalos[id_str] = {"OA": oa[:10], "OF": of[:10]}

    return intervalos


# =========================
# UTIL
# =========================
def salvar_json(path, payload):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(payload, f, indent=2, ensure_ascii=False)


def extrair_segmento(sig_1d, sfreq, inicio_s, dur_s):
    ini = int(round(inicio_s * sfreq))
    fim = int(round((inicio_s + dur_s) * sfreq))
    ini = max(0, ini)
    fim = min(sig_1d.shape[0], fim)
    if fim <= ini:
        return None
    return sig_1d[ini:fim]


def welch_psd(sig_1d, sfreq):
    n = sig_1d.shape[0]
    if n < int(sfreq):
        return None, None

    nperseg  = min(max(int(round(WELCH_WIN_SEC * sfreq)), int(sfreq)), n)
    noverlap = min(int(round(WELCH_OVERLAP_FRAC * nperseg)), nperseg - 1)
    nfft     = max(int(4 * sfreq), NFFT_MIN)

    freqs, pxx = welch(sig_1d, fs=sfreq,
                       nperseg=nperseg, noverlap=noverlap, nfft=nfft)
    return freqs, pxx


def idx_range(freqs, fmin, fmax):
    return (freqs >= fmin) & (freqs <= fmax)


# =========================
# FOOOF NO PSD MÉDIO
# =========================
def ajustar_fooof_no_psd_medio(freqs, psd_med, fmin=FMIN_GLOBAL, fmax=FMAX_GLOBAL):
    idx = idx_range(freqs, fmin, fmax)
    if idx.sum() < 20:
        return None

    f = freqs[idx]
    p = psd_med[idx]

    if np.any(~np.isfinite(p)) or np.any(p <= 0):
        return None

    fm = FOOOF(**FOOOF_CONFIG)
    fm.fit(f, p)

    r2  = float(getattr(fm, "r_squared_", 0.0) or 0.0)
    err = float(getattr(fm, "error_",     np.inf) or np.inf)
    ok  = (r2 >= FOOOF_R2_MIN) and (err <= FOOOF_ERR_MAX)

    orig_micro     = p                            * 1e12
    ap_micro       = (10 ** fm._ap_fit)           * 1e12
    full_micro     = (10 ** fm.fooofed_spectrum_) * 1e12
    periodic_micro = full_micro - ap_micro

    ap_params = list(fm.aperiodic_params_) if hasattr(fm, "aperiodic_params_") else []

    return {
        "ok":             ok,
        "fm":             fm,
        "freqs":          f,
        "orig_micro":     orig_micro,
        "ap_micro":       ap_micro,
        "full_micro":     full_micro,
        "periodic_micro": periodic_micro,
        "r2":             r2,
        "err":            err,
        "ap_params":      ap_params,
    }


def metricas_por_banda(freqs, orig_micro, ap_micro, periodic_micro, fmin, fmax):
    idx = idx_range(freqs, fmin, fmax)
    if idx.sum() < 5:
        return None

    f = freqs[idx]
    o = orig_micro[idx]
    a = ap_micro[idx]
    p = periodic_micro[idx]

    return {
        "psd_media_original":  float(np.mean(o)),
        "area_original":       float(np.trapezoid(o, f)),
        "psd_media_aperiodic": float(np.mean(a)),
        "area_aperiodic":      float(np.trapezoid(a, f)),
        "psd_media_periodic":  float(np.mean(p)),
        "area_periodic":       float(np.trapezoid(p, f)),
    }


def resumo_picos_faixa(fm, fmin, fmax):
    peaks = getattr(fm, "peak_params_", None)
    if peaks is None or len(peaks) == 0:
        return {"n": 0, "freq_media": None, "amp_media": None, "bw_media": None}

    peaks = np.array(peaks)
    freqs = peaks[:, 0]
    amps  = peaks[:, 1]
    bws   = peaks[:, 2]
    m     = (freqs >= fmin) & (freqs <= fmax)

    if m.sum() == 0:
        return {"n": 0, "freq_media": None, "amp_media": None, "bw_media": None}

    return {
        "n":          int(m.sum()),
        "freq_media": float(np.mean(freqs[m])),
        "amp_media":  float(np.mean(amps[m])),
        "bw_media":   float(np.mean(bws[m])),
    }


# =========================
# IC 95% DOS SEGMENTOS
# =========================
def calcular_ci95(psds_list, freqs_ref):
    """
    Recebe lista de PSDs individuais (em V²/Hz) e retorna
    mean, lo, hi em µV²/Hz na faixa global.
    """
    if not psds_list:
        return None, None, None

    mat  = np.stack(psds_list, axis=0) * 1e12   # (n_segs, n_freqs) em µV²/Hz
    n    = mat.shape[0]
    mean = np.mean(mat, axis=0)
    sem  = np.std(mat, axis=0, ddof=1) / np.sqrt(n)
    t    = 2.262 if n <= 10 else 1.96            # t crítico df=9 → 95%
    lo   = mean - t * sem
    hi   = mean + t * sem
    return mean, lo, hi


# =========================
# GAUSSIANA FOOOF
# =========================
def _gaussiana(cf, amp, bw, freqs):
    """Reconstrói gaussiana individual do FOOOF (amplitude em log-space → µV²/Hz)."""
    return amp * np.exp(-0.5 * ((freqs - cf) / (bw / 2)) ** 2) * 1e12


# =========================
# PLOT PARA PUBLICAÇÃO
# 3 painéis:
#   A — Espectro completo (log Y) OA vs OF + IC 95% + aperiódico + bandas
#   B — Periódico isolado OA vs OF + gaussianas FOOOF individuais
#   C — Barplot expoente aperiódico OA vs OF (E/I balance)
# =========================
def plot_publicacao(paciente_id, canal, pasta_saida,
                    freqs_ref_oa, psd_med_oa, psds_ind_oa, foo_oa,
                    freqs_ref_of, psd_med_of, psds_ind_of, foo_of):
    """
    Gera figura de 3 painéis pronta para publicação (DPI 300).

    Parâmetros
    ----------
    psds_ind_oa / psds_ind_of : listas de arrays PSD individuais em V²/Hz
                                 (SEM *1e12) — usados para calcular IC 95%
    foo_oa / foo_of           : dicts retornados por ajustar_fooof_no_psd_medio()
                                 ou None se FOOOF falhou
    """

    plt.rcParams.update({
        "font.family":       "DejaVu Sans",
        "font.size":         10,
        "axes.titlesize":    11,
        "axes.labelsize":    10,
        "xtick.labelsize":   9,
        "ytick.labelsize":   9,
        "axes.spines.top":   False,
        "axes.spines.right": False,
    })

    fig = plt.figure(figsize=(18, 6), facecolor="white", constrained_layout=True)
    gs  = GridSpec(1, 3, figure=fig, width_ratios=[5, 4, 2])
    ax_a = fig.add_subplot(gs[0])
    ax_b = fig.add_subplot(gs[1])
    ax_c = fig.add_subplot(gs[2])

    # ── Prepara arrays em µV²/Hz ────────────────────────────────────────────
    def _prep(freqs_ref, psd_med, psds_ind, foo):
        idx  = idx_range(freqs_ref, FMIN_GLOBAL, FMAX_GLOBAL)
        f    = freqs_ref[idx]
        p    = psd_med[idx] * 1e12

        mean_ci, lo_ci, hi_ci = calcular_ci95(psds_ind, freqs_ref)
        if mean_ci is not None:
            mean_ci = mean_ci[idx]
            lo_ci   = lo_ci[idx]
            hi_ci   = hi_ci[idx]

        ap   = (10 ** foo["fm"]._ap_fit)           * 1e12 if foo else None
        per  = foo["periodic_micro"]                       if foo else None
        fq   = foo["freqs"]                                if foo else f

        return f, p, lo_ci, hi_ci, ap, per, fq

    f_oa, p_oa, lo_oa, hi_oa, ap_oa, per_oa, fq_oa = _prep(
        freqs_ref_oa, psd_med_oa, psds_ind_oa, foo_oa)
    f_of, p_of, lo_of, hi_of, ap_of, per_of, fq_of = _prep(
        freqs_ref_of, psd_med_of, psds_ind_of, foo_of)

    exp_oa = foo_oa["ap_params"][1] if (foo_oa and len(foo_oa["ap_params"]) >= 2) else None
    exp_of = foo_of["ap_params"][1] if (foo_of and len(foo_of["ap_params"]) >= 2) else None

    # ── Helper: sombrear bandas ─────────────────────────────────────────────
    def _bandas(ax, yref_transform=False):
        for nome, (bmin, bmax, cor, alpha) in BANDAS_PLOT.items():
            ax.axvspan(bmin, bmax, color=cor, alpha=alpha, zorder=0)
            if yref_transform:
                ax.text((bmin + bmax) / 2, 0.97, nome,
                        ha="center", va="top", fontsize=8.5,
                        color="#555", fontstyle="italic",
                        transform=ax.get_xaxis_transform())
            else:
                ylim = ax.get_ylim()
                ax.text((bmin + bmax) / 2, ylim[1] * 0.96, nome,
                        ha="center", va="top", fontsize=8.5,
                        color="#555", fontstyle="italic")

    # ════════════════════════════════════════════════════════════════════════
    # PAINEL A — Espectro completo (escala log Y)
    # ════════════════════════════════════════════════════════════════════════

    # IC 95% sombreado
    if lo_oa is not None:
        ax_a.fill_between(f_oa, lo_oa, hi_oa, color=COR_OA, alpha=0.15, zorder=1)
    if lo_of is not None:
        ax_a.fill_between(f_of, lo_of, hi_of, color=COR_OF, alpha=0.15, zorder=1)

    # Aperiódico tracejado
    if ap_oa is not None:
        ax_a.semilogy(fq_oa, ap_oa, color=COR_AP_OA, ls="--", lw=1.4, alpha=0.85, zorder=2)
    if ap_of is not None:
        ax_a.semilogy(fq_of, ap_of, color=COR_AP_OF, ls="--", lw=1.4, alpha=0.85, zorder=2)

    # Espectro médio
    ax_a.semilogy(f_oa, p_oa, color=COR_OA, lw=2.2, zorder=3)
    ax_a.semilogy(f_of, p_of, color=COR_OF, lw=2.2, zorder=3)

    ax_a.set_xlim(FMIN_GLOBAL, FMAX_GLOBAL)
    ax_a.set_xlabel("Frequency (Hz)")
    ax_a.set_ylabel("Power Spectral Density (µV²/Hz)")
    ax_a.set_title("A  —  Power Spectrum", fontweight="bold", loc="left", pad=8)
    _bandas(ax_a, yref_transform=True)

    leg_a = [
        Line2D([0],[0], color=COR_OA, lw=2,   label="Eyes Open (OA)"),
        Line2D([0],[0], color=COR_OF, lw=2,   label="Eyes Closed (OF)"),
        mpatches.Patch(color=COR_OA, alpha=0.25, label="95% CI (OA)"),
        mpatches.Patch(color=COR_OF, alpha=0.25, label="95% CI (OF)"),
        Line2D([0],[0], color="#999", lw=1.3, ls="--", label="Aperiodic fit"),
    ]
    ax_a.legend(handles=leg_a, fontsize=8.5, frameon=False, loc="upper right")
    ax_a.grid(True, which="both", ls=":", alpha=0.25, color="gray")

    # ════════════════════════════════════════════════════════════════════════
    # PAINEL B — Periódico isolado + gaussianas FOOOF
    # ════════════════════════════════════════════════════════════════════════

    if per_oa is not None:
        ax_b.plot(fq_oa, per_oa, color=COR_OA, lw=2.2, zorder=3)
        ax_b.fill_between(fq_oa, 0, per_oa, color=COR_OA, alpha=0.12, zorder=2)

    if per_of is not None:
        ax_b.plot(fq_of, per_of, color=COR_OF, lw=2.2, zorder=3)
        ax_b.fill_between(fq_of, 0, per_of, color=COR_OF, alpha=0.12, zorder=2)

    # Gaussianas individuais — mostram EXATAMENTE onde o FOOOF detectou picos
    def _plot_gaussianas(ax, foo, fq, cor_gauss):
        if foo is None:
            return
        peaks = getattr(foo["fm"], "gaussian_params_", None)
        if peaks is None or len(peaks) == 0:
            return
        ylim_now = ax.get_ylim()
        for cf, amp, bw in np.array(peaks):
            curva = _gaussiana(cf, amp, bw, fq)
            ax.plot(fq, curva, color=cor_gauss, lw=1.4, ls="-.", alpha=0.9, zorder=4)
            ax.axvline(cf, color=cor_gauss, lw=0.9, ls=":", alpha=0.75, zorder=4)
            ax.text(cf + 0.35, ylim_now[1] * 0.06 if ylim_now[1] > 0 else 0.01,
                    f"{cf:.1f} Hz", fontsize=7.5,
                    color=cor_gauss, fontweight="bold", va="bottom")

    _plot_gaussianas(ax_b, foo_oa, fq_oa, "#1A6399")
    _plot_gaussianas(ax_b, foo_of, fq_of, "#B22222")

    ax_b.axhline(0, color="black", lw=0.6)
    ax_b.set_xlim(FMIN_GLOBAL, FMAX_GLOBAL)
    ax_b.set_xlabel("Frequency (Hz)")
    ax_b.set_ylabel("Periodic Power (µV²/Hz)")
    ax_b.set_title("B  —  Periodic Component (FOOOF)", fontweight="bold", loc="left", pad=8)
    _bandas(ax_b)

    leg_b = [
        Line2D([0],[0], color=COR_OA, lw=2,   label="Eyes Open (OA)"),
        Line2D([0],[0], color=COR_OF, lw=2,   label="Eyes Closed (OF)"),
        Line2D([0],[0], color="#555", lw=1.3, ls="-.", label="FOOOF gaussian peak"),
    ]
    ax_b.legend(handles=leg_b, fontsize=8.5, frameon=False, loc="upper right")
    ax_b.grid(True, ls=":", alpha=0.25, color="gray")

    # ════════════════════════════════════════════════════════════════════════
    # PAINEL C — Barplot expoente aperiódico (E/I balance)
    # ════════════════════════════════════════════════════════════════════════

    labels  = ["Eyes\nOpen", "Eyes\nClosed"]
    valores = [exp_oa if exp_oa is not None else 0,
               exp_of if exp_of is not None else 0]
    validos = [exp_oa is not None, exp_of is not None]

    bars = ax_c.bar(labels, valores, color=[COR_OA, COR_OF],
                    width=0.5, edgecolor="white", lw=0.8, alpha=0.88, zorder=2)

    vmax = max([v for v, ok in zip(valores, validos) if ok] or [1])
    for bar, val, ok in zip(bars, valores, validos):
        txt = f"{val:.3f}" if ok else "N/A"
        ax_c.text(bar.get_x() + bar.get_width() / 2,
                  val + vmax * 0.03, txt,
                  ha="center", va="bottom",
                  fontsize=9.5, fontweight="bold", color="#222")

    ax_c.set_ylabel("Aperiodic Exponent (1/f slope)")
    ax_c.set_title("C  —  E/I Balance", fontweight="bold", loc="left", pad=8)
    ax_c.set_ylim(0, vmax * 1.30)
    ax_c.axhline(0, color="black", lw=0.6)
    ax_c.grid(True, axis="y", ls=":", alpha=0.3, color="gray")
    ax_c.text(0.5, 0.03, "Higher = more\ninhibitory dominance",
              ha="center", transform=ax_c.transAxes,
              fontsize=7.5, color="#777", fontstyle="italic")

    # ── Título geral ─────────────────────────────────────────────────────────
    r2_oa = f"{foo_oa['r2']:.3f}" if foo_oa else "N/A"
    r2_of = f"{foo_of['r2']:.3f}" if foo_of else "N/A"
    ok_oa = "✓" if (foo_oa and foo_oa["ok"]) else "✗"
    ok_of = "✓" if (foo_of and foo_of["ok"]) else "✗"

    fig.suptitle(
        f"EEG Spectral Analysis  |  {paciente_id}  —  Channel {canal}  (Pre-intervention)\n"
        f"FOOOF fit: OA R²={r2_oa} {ok_oa}  |  OF R²={r2_of} {ok_of}"
        f"   [Donoghue et al., 2020]",
        fontsize=10.5, fontweight="bold", color="#222", y=1.02
    )

    # ── Salvar ───────────────────────────────────────────────────────────────
    nome_png = f"{paciente_id}_{canal}_FOOOF_PUB.png"
    fig.savefig(os.path.join(pasta_saida, nome_png),
                dpi=300, bbox_inches="tight",
                facecolor="white", edgecolor="none")
    plt.close(fig)


# =========================
# TXT COMPLETO
# =========================
def salvar_txt_resumo(pasta_saida, paciente_id, canal, cond, n_validos,
                      resultados_por_banda, fooof_info,
                      inicios_intervalos=None, psds_brutos=None):
    caminho   = os.path.join(pasta_saida, f"{paciente_id}_{canal}_{cond}_RESUMO.txt")
    fm        = fooof_info.get("fm")
    ap_params = fooof_info.get("ap_params", [])

    with open(caminho, "w", encoding="utf-8") as f:

        f.write("=" * 75 + "\n")
        f.write("ANALISE EEG/FOOOF COMPLETA\n")
        f.write("Referencia: Donoghue et al. (2020) Nature Neuroscience\n")
        f.write("=" * 75 + "\n")
        f.write(f"Paciente          : {paciente_id}\n")
        f.write(f"Canal             : {canal}\n")
        f.write(f"Condicao          : {'Olhos Abertos' if cond == 'OA' else 'Olhos Fechados'}\n")
        f.write(f"Segmentos validos : {n_validos}/10  ({DURACAO_INTERVALO}s cada)\n")
        f.write(f"Gerado em         : {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n")
        f.write("=" * 75 + "\n\n")

        f.write("METODOLOGIA:\n")
        f.write(f"  1. PSD estimado pelo metodo de Welch (janela={WELCH_WIN_SEC}s, "
                f"sobreposicao={int(WELCH_OVERLAP_FRAC*100)}%) em cada segmento de {DURACAO_INTERVALO}s.\n")
        f.write(f"  2. Media dos {n_validos} PSDs individuais -> espectro medio estavel.\n")
        f.write(f"  3. FOOOF ajustado UMA VEZ no espectro medio ({FMIN_GLOBAL}-{FMAX_GLOBAL} Hz).\n")
        f.write(f"  4. Decomposicao: Aperiodico (1/f) + Periodico (oscilacoes reais).\n")
        f.write(f"  5. Picos detectados via ajuste gaussiano (centroide = frequencia real).\n\n")

        f.write("-" * 75 + "\n")
        f.write("1. QUALIDADE DO AJUSTE FOOOF + PARAMETROS APERIODICOS\n")
        f.write("-" * 75 + "\n")
        f.write(f"  R2            : {fooof_info['r2']:.4f}  (minimo aceitavel: {FOOOF_R2_MIN})\n")
        f.write(f"  Erro medio    : {fooof_info['err']:.4f}  (maximo aceitavel: {FOOOF_ERR_MAX})\n")
        f.write(f"  Ajuste OK     : {fooof_info['ok']}\n\n")
        f.write("  PARAMETROS APERIODICOS:\n")
        f.write("  O expoente aperiodico reflete o balanco excitacao/inibicao (E/I) cortical.\n")
        f.write("  Expoentes maiores -> maior dominancia inibitoria. (Donoghue et al. 2020)\n\n")

        if fm is not None and hasattr(fm, "aperiodic_params_"):
            ap = fm.aperiodic_params_
            f.write(f"  Offset         : {ap[0]:.4f}  (intercepto do espectro em log)\n")
            if len(ap) == 2:
                f.write(f"  Expoente (1/f) : {ap[1]:.4f}  <- METRICA PRINCIPAL E/I\n")
            elif len(ap) == 3:
                f.write(f"  Knee           : {ap[1]:.4f}\n")
                f.write(f"  Expoente (1/f) : {ap[2]:.4f}  <- METRICA PRINCIPAL E/I\n")
        else:
            f.write("  Parametros aperiodicos nao disponiveis.\n")
        f.write("\n")

        f.write("-" * 75 + "\n")
        f.write("2. METRICAS POR BANDA\n")
        f.write("   Calculadas sobre o espectro medio decomposto pelo FOOOF.\n")
        f.write("-" * 75 + "\n\n")

        for banda, met in resultados_por_banda.items():
            bmin, bmax = BANDAS[banda]
            f.write(f"  +- {banda.upper()} ({bmin}-{bmax} Hz) {'-' * (44 - len(banda))}\n")

            if met is None:
                f.write("  |  Dados insuficientes nesta banda.\n")
                f.write("  +" + "-" * 50 + "\n\n")
                continue

            f.write("  |\n")
            f.write("  |  ORIGINAL (Welch medio, sem decomposicao):\n")
            f.write(f"  |    PSD media : {met['psd_media_original']:.5f} uV2/Hz\n")
            f.write(f"  |    Area      : {met['area_original']:.5f} uV2\n")
            f.write("  |\n")
            f.write("  |  APERIODICO (ruido de fundo 1/f):\n")
            f.write(f"  |    PSD media : {met['psd_media_aperiodic']:.5f} uV2/Hz\n")
            f.write(f"  |    Area      : {met['area_aperiodic']:.5f} uV2\n")
            f.write("  |\n")
            f.write("  |  PERIODICO (oscilacoes reais):\n")
            f.write(f"  |    PSD media : {met['psd_media_periodic']:.5f} uV2/Hz\n")
            f.write(f"  |    Area      : {met['area_periodic']:.5f} uV2\n")

            if fm is not None:
                peaks_raw = getattr(fm, "peak_params_", None)
                if peaks_raw is not None and len(peaks_raw) > 0:
                    pk_arr      = np.array(peaks_raw)
                    mask        = (pk_arr[:, 0] >= bmin) & (pk_arr[:, 0] <= bmax)
                    picos_banda = pk_arr[mask]

                    if len(picos_banda) > 0:
                        f.write("  |\n")
                        f.write(f"  |  PICOS FOOOF — gaussianas ({len(picos_banda)} encontrado(s)):\n")
                        f.write("  |  NOTA: frequencia = centroide gaussiano (mais preciso que maximo visual)\n")

                        for j, (freq_pk, amp_pk, bw_pk) in enumerate(picos_banda, 1):
                            try:
                                ap_mean_log = np.mean(np.log10(
                                    met['psd_media_aperiodic'] / 1e12 + 1e-30))
                                psd_abs = (10 ** (ap_mean_log + amp_pk) -
                                           10 ** ap_mean_log) * 1e12
                            except Exception:
                                psd_abs = float("nan")

                            f.write(f"  |    Pico {j}:\n")
                            f.write(f"  |      Frequencia (CF)  : {freq_pk:.2f} Hz\n")
                            f.write(f"  |      PSD no pico      : {psd_abs:.5f} uV2/Hz\n")
                            f.write(f"  |      Largura (BW)     : {bw_pk:.2f} Hz\n")
                            f.write(f"  |      Amp. log (FOOOF) : {amp_pk:.4f}\n")
                    else:
                        f.write("  |\n")
                        f.write("  |  PICOS: nenhum detectado nesta banda.\n")

            f.write("  +" + "-" * 50 + "\n\n")

        f.write("-" * 75 + "\n")
        f.write("3. PSD BRUTO POR SEGMENTO -- APENAS CONTROLE DE QUALIDADE\n")
        f.write("   ATENCAO: valores abaixo SAO o Welch cru, SEM decomposicao FOOOF.\n")
        f.write("   Incluem ruido 1/f.\n")
        f.write("-" * 75 + "\n\n")

        if inicios_intervalos is None or psds_brutos is None:
            f.write("  (dados por segmento nao disponiveis)\n")
        else:
            for k, (inicio_s, psd_raw) in enumerate(
                    zip(inicios_intervalos, psds_brutos), 1):
                fim_s = inicio_s + DURACAO_INTERVALO
                f.write(f"  Segmento {k:02d}: {inicio_s:.0f}s - {fim_s:.0f}s\n")

                if psd_raw is None:
                    f.write("    Invalido (fora da duracao ou falha no Welch)\n\n")
                    continue

                freqs_int, pxx_int = psd_raw
                for banda, (bmin, bmax) in BANDAS.items():
                    idxb    = idx_range(freqs_int, bmin, bmax)
                    if idxb.sum() < 3:
                        continue
                    f_b      = freqs_int[idxb]
                    p_b      = pxx_int[idxb] * 1e12
                    psd_m    = float(np.mean(p_b))
                    area     = float(np.trapezoid(p_b, f_b))
                    psd_max  = float(np.max(p_b))
                    freq_max = float(f_b[np.argmax(p_b)])
                    f.write(
                        f"    {banda.upper():5s} ({bmin:.0f}-{bmax:.0f} Hz): "
                        f"PSD media={psd_m:.5f} uV2/Hz | "
                        f"Area={area:.5f} uV2 | "
                        f"Pico={psd_max:.5f} uV2/Hz  {freq_max:.2f} Hz\n"
                    )
                f.write("\n")

        f.write("=" * 75 + "\n")


# =========================
# MAIN
# =========================
if __name__ == "__main__":

    intervalos_planilha = carregar_intervalos_planilha(PLANILHA_PATH)
    if not intervalos_planilha:
        raise SystemExit("Nao foi possivel ler intervalos da planilha.")

    log_geral = {
        "timestamp":  datetime.now().isoformat(),
        "referencia": "Donoghue et al. (2020) Nature Neuroscience",
        "planilha":   PLANILHA_PATH,
        "saida":      PASTA_SAIDA,
        "parametros": {
            "duracao_intervalo_s": DURACAO_INTERVALO,
            "fmin_global":         FMIN_GLOBAL,
            "fmax_global":         FMAX_GLOBAL,
            "bandas":              BANDAS,
            "welch_win_sec":       WELCH_WIN_SEC,
            "welch_overlap_frac":  WELCH_OVERLAP_FRAC,
            "nfft_min":            NFFT_MIN,
            "fooof_config":        FOOOF_CONFIG,
            "fooof_r2_min":        FOOOF_R2_MIN,
            "fooof_err_max":       FOOOF_ERR_MAX,
        },
        "ambiente": {
            "python":   platform.python_version(),
            "mne":      mne.__version__,
            "platform": platform.platform(),
        },
        "arquivos_processados": []
    }

    print("\n" + "=" * 80)
    print("ANALISE EEG - FOOOF")
    print("Pipeline: Welch por segmento -> media PSD -> FOOOF 1x -> metricas")
    print("Plot: 3 painéis para publicação (DPI 300)")
    print("=" * 80)

    for nome_arquivo in sorted(os.listdir(PASTA_SET)):
        if not nome_arquivo.endswith(".set"):
            continue

        caminho     = os.path.join(PASTA_SET, nome_arquivo)
        paciente_id = Path(caminho).stem

        chave_encontrada = None
        if paciente_id in intervalos_planilha:
            chave_encontrada = paciente_id
        else:
            for chave in intervalos_planilha:
                if str(chave) in paciente_id or paciente_id in str(chave):
                    chave_encontrada = chave
                    break

        if chave_encontrada is None:
            print(f"  '{paciente_id}' nao encontrado na planilha -- pulando")
            continue

        print(f"\n> {nome_arquivo}  |  ID: {paciente_id}")

        item_log = {
            "id": paciente_id, "arquivo": caminho,
            "processado": True, "sfreq": None,
            "duracao_s": None,  "n_canais": None,
            "falhas_segmento": 0, "canais": {}
        }

        try:
            raw       = mne.io.read_raw_eeglab(caminho, preload=True)
            data      = raw.get_data()
            sfreq     = float(raw.info["sfreq"])
            ch_names  = list(raw.info["ch_names"])
            dur_total = data.shape[1] / sfreq

            item_log.update({"sfreq": sfreq,
                             "duracao_s": float(dur_total),
                             "n_canais":  int(len(ch_names))})

            print(f"   {dur_total:.1f}s | {len(ch_names)} canais | {sfreq:.0f} Hz")

            ints = intervalos_planilha[chave_encontrada]

            for ch_idx, canal in enumerate(ch_names):
                sig = data[ch_idx, :]
                if np.all(sig == 0):
                    continue

                print(f"   Canal {canal} ...", end=" ", flush=True)
                item_log["canais"][canal] = {}

                # ── Acumula dados de OA e OF para plot conjunto ──────────────
                dados_por_cond = {}   # {"OA": {...}, "OF": {...}}

                for cond in ["OA", "OF"]:
                    inicios   = ints[cond]
                    psds      = []          # PSDs individuais (V²/Hz) para IC 95%
                    freqs_ref = None
                    usados    = 0
                    psds_brutos_por_segmento = []
                    inicios_todos = []

                    for inicio_s in inicios:
                        inicios_todos.append(inicio_s)

                        if inicio_s + DURACAO_INTERVALO > dur_total:
                            item_log["falhas_segmento"] += 1
                            psds_brutos_por_segmento.append(None)
                            continue

                        seg = extrair_segmento(sig, sfreq, inicio_s, DURACAO_INTERVALO)
                        if seg is None or seg.size < int(sfreq):
                            item_log["falhas_segmento"] += 1
                            psds_brutos_por_segmento.append(None)
                            continue

                        freqs, pxx = welch_psd(seg, sfreq)
                        if freqs is None:
                            item_log["falhas_segmento"] += 1
                            psds_brutos_por_segmento.append(None)
                            continue

                        idxg    = idx_range(freqs, FMIN_GLOBAL, FMAX_GLOBAL)
                        freqs_g = freqs[idxg]
                        pxx_g   = pxx[idxg]

                        if (idxg.sum() < 20 or
                                np.any(~np.isfinite(pxx_g)) or
                                np.any(pxx_g <= 0)):
                            item_log["falhas_segmento"] += 1
                            psds_brutos_por_segmento.append(None)
                            continue

                        psds_brutos_por_segmento.append((freqs, pxx))

                        if freqs_ref is None:
                            freqs_ref = freqs_g
                        elif (len(freqs_g) != len(freqs_ref) or
                              not np.allclose(freqs_g, freqs_ref)):
                            pxx_g = np.interp(freqs_ref, freqs_g, pxx_g)

                        psds.append(pxx_g)   # V²/Hz — SEM *1e12
                        usados += 1

                    item_log["canais"][canal][cond] = {
                        "segmentos_validos": usados,
                        "segmentos_total":   NUM_INTERVALOS_OA,
                    }

                    if usados < 1:
                        dados_por_cond[cond] = None
                        continue

                    psd_med = np.mean(np.stack(psds, axis=0), axis=0)
                    foo     = ajustar_fooof_no_psd_medio(freqs_ref, psd_med)

                    if foo is None:
                        item_log["canais"][canal][cond]["fooof_ok"] = False
                        dados_por_cond[cond] = None
                        continue

                    item_log["canais"][canal][cond].update({
                        "fooof_ok": bool(foo["ok"]),
                        "r2":       float(foo["r2"]),
                        "err":      float(foo["err"]),
                        "expoente": float(foo["ap_params"][1])
                                    if len(foo["ap_params"]) >= 2 else None,
                    })

                    # Métricas por banda + TXT
                    resultados_bandas = {}
                    for banda_nome, (bmin, bmax) in BANDAS.items():
                        met = metricas_por_banda(
                            foo["freqs"], foo["orig_micro"],
                            foo["ap_micro"], foo["periodic_micro"],
                            bmin, bmax
                        )
                        resultados_bandas[banda_nome] = met

                    fooof_info_txt = {
                        "ok":        foo["ok"],
                        "r2":        foo["r2"],
                        "err":       foo["err"],
                        "fm":        foo["fm"],
                        "ap_params": foo["ap_params"],
                    }
                    salvar_txt_resumo(
                        pasta_saida=PASTA_SAIDA,
                        paciente_id=paciente_id,
                        canal=canal, cond=cond,
                        n_validos=usados,
                        resultados_por_banda=resultados_bandas,
                        fooof_info=fooof_info_txt,
                        inicios_intervalos=inicios_todos,
                        psds_brutos=psds_brutos_por_segmento,
                    )

                    # Guarda tudo para o plot conjunto OA+OF
                    dados_por_cond[cond] = {
                        "freqs_ref": freqs_ref,
                        "psd_med":   psd_med,     # V²/Hz
                        "psds_ind":  psds,         # lista de arrays V²/Hz
                        "foo":       foo,
                        "usados":    usados,
                    }

                # ── Gera o plot conjunto OA vs OF (1 figura por canal) ───────
                d_oa = dados_por_cond.get("OA")
                d_of = dados_por_cond.get("OF")

                if d_oa is not None or d_of is not None:
                    # Fallback: se uma condição falhou, usa arrays zerados
                    def _fallback(d_ref):
                        """Cria estrutura mínima para condição sem dados."""
                        return {
                            "freqs_ref": d_ref["freqs_ref"],
                            "psd_med":   np.zeros_like(d_ref["psd_med"]),
                            "psds_ind":  [],
                            "foo":       None,
                            "usados":    0,
                        }

                    if d_oa is None and d_of is not None:
                        d_oa = _fallback(d_of)
                    if d_of is None and d_oa is not None:
                        d_of = _fallback(d_oa)

                    plot_publicacao(
                        paciente_id=paciente_id,
                        canal=canal,
                        pasta_saida=PASTA_SAIDA,
                        freqs_ref_oa=d_oa["freqs_ref"],
                        psd_med_oa=d_oa["psd_med"],
                        psds_ind_oa=d_oa["psds_ind"],
                        foo_oa=d_oa["foo"],
                        freqs_ref_of=d_of["freqs_ref"],
                        psd_med_of=d_of["psd_med"],
                        psds_ind_of=d_of["psds_ind"],
                        foo_of=d_of["foo"],
                    )

                # Print status
                foo_ultimo = (dados_por_cond.get("OF") or dados_por_cond.get("OA"))
                if foo_ultimo and foo_ultimo["foo"] and len(foo_ultimo["foo"].get("ap_params", [])) >= 2:
                    print(f"OK (R2={foo_ultimo['foo']['r2']:.2f} | exp={foo_ultimo['foo']['ap_params'][1]:.3f})")
                else:
                    print("OK")

                gc.collect()

        except Exception as e:
            item_log["processado"] = False
            item_log["erro"]       = str(e)
            print(f"\nErro em {nome_arquivo}: {e}")
            import traceback; traceback.print_exc()

        log_geral["arquivos_processados"].append(item_log)

    ts       = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_path = os.path.join(PASTA_SAIDA, f"ANALISE_LOG_{ts}.json")
    salvar_json(log_path, log_geral)

    print("\n" + "=" * 80)
    print("PROCESSAMENTO CONCLUIDO!")
    print(f"Saida : {PASTA_SAIDA}")
    print(f"Log   : {log_path}")
    print("=" * 80)
